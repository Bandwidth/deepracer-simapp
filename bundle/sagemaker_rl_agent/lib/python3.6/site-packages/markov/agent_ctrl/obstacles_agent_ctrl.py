'''This module implements concrete agent controllers for the rollout worker'''
import numpy as np
import os
import random
import rospkg
import rospy
import math

from shapely.geometry import Point, Polygon, LineString, LinearRing

from gazebo_msgs.msg import ModelState
from gazebo_msgs.srv import SpawnModel
from markov.agent_ctrl.constants import BOT_CAR_Z, OBSTACLE_Z, OBSTACLE_NAME_PREFIX
from markov.track_geom.constants import SPAWN_SDF_MODEL, SPAWN_URDF_MODEL, ObstacleDimensions
from markov.track_geom.track_data import TrackData
from markov.track_geom.utils import euler_to_quaternion
from markov.agent_ctrl.agent_ctrl_interface import AgentCtrlInterface
from markov.rospy_wrappers import ServiceProxyWrapper
from markov import utils
from markov.reset.constants import AgentInfo
from markov.domain_randomizations.randomizer_manager import RandomizerManager
from markov.domain_randomizations.visual.model_visual_randomizer import ModelVisualRandomizer
from markov.domain_randomizations.constants import ModelRandomizerType
from markov.gazebo_tracker.trackers.set_model_state_tracker import SetModelStateTracker

NUM_OFFTRACK_OBSTACLES = 20

class ObstaclesCtrl(AgentCtrlInterface):
    def __init__(self):
        # Read ros parameters
        # OBJECT_POSITIONS will overwrite NUMBER_OF_OBSTACLES and RANDOMIZE_OBSTACLE_LOCATIONS
        self.object_locations = rospy.get_param("OBJECT_POSITIONS", [])
        self.num_obstacles = int(rospy.get_param("NUMBER_OF_OBSTACLES", 0)) \
                             if not self.object_locations else len(self.object_locations)
        self.min_obstacle_dist = float(rospy.get_param("MIN_DISTANCE_BETWEEN_OBSTACLES", 2.0))
        self.randomize = utils.str2bool(rospy.get_param("RANDOMIZE_OBSTACLE_LOCATIONS", False))
        self.use_bot_car = utils.str2bool(rospy.get_param("IS_OBSTACLE_BOT_CAR", False))
        self.obstacle_names = ["{}_{}".format(OBSTACLE_NAME_PREFIX, i) for i in range(self.num_obstacles+NUM_OFFTRACK_OBSTACLES)]

        # Randomize obstacle types
        obj_types = ["bot_car","box_obstacle"]
        self.obstacle_types = [random.choice(obj_types) for i in range(len(self.obstacle_names))]
        self.obstacle_dimensions = {
            "bot_car": ObstacleDimensions.BOT_CAR_DIMENSION,
            "box_obstacle": ObstacleDimensions.BOX_OBSTACLE_DIMENSION
        }
        self.obstacle_z_pos = {
            "bot_car": BOT_CAR_Z,
            "box_obstacle": OBSTACLE_Z
        }

        # track data
        self.track_data = TrackData.get_instance()

        # Wait for ros services
        rospy.wait_for_service(SPAWN_SDF_MODEL)
        rospy.wait_for_service(SPAWN_URDF_MODEL)
        self.spawn_sdf_model = ServiceProxyWrapper(SPAWN_SDF_MODEL, SpawnModel)
        self.spawn_urdf_model = ServiceProxyWrapper(SPAWN_URDF_MODEL, SpawnModel)

        # Load the obstacle sdf/urdf
        rospack = rospkg.RosPack()
        deepracer_path = rospack.get_path("deepracer_simulation_environment")

        self.obstacle_sdf = {}
        for fld in obj_types:
            obstacle_sdf_path = os.path.join(deepracer_path, "models", fld, "model.sdf")
            with open(obstacle_sdf_path, "r") as fp:
                self.obstacle_sdf[fld] = fp.read()

        # Set obstacle poses and spawn the obstacles
        self.obstacle_poses = self._compute_obstacle_poses()
        self._spawn_obstacles()

        self._configure_randomizer()

    def _configure_randomizer(self):
        '''configure domain randomizer
        '''
        for obstacle_names in self.obstacle_names:
            RandomizerManager.get_instance().add(ModelVisualRandomizer(model_name=obstacle_names,
                                                                       model_randomizer_type=ModelRandomizerType.MODEL))


    # -------------------------------------------------
    def _randomize_off_track_obstacles(self, obstacle_poses):

        # -------------------------------------------------
        def make_off_track_obstacles(min_obstacle_dist,inner_lane,center_line,outer_lane,obstacle_poses):
            obstacle_dists = []
            obstacle_lanes = []

            # Start with equally spaced
            obstacle_start_dist = min_obstacle_dist
            obstacle_end_dist = center_line.length - 1.0
            obstacle_dists = np.linspace(obstacle_start_dist, obstacle_end_dist, NUM_OFFTRACK_OBSTACLES)

            # Perturb to achieve randomness
            for i in range(0,len(obstacle_dists)):
                obstacle_dists[i] += random.uniform(-min_obstacle_dist/2.0, min_obstacle_dist/2.0)

            # Select a random lane for each obstacle
            lane_choices = (inner_lane, outer_lane)
            for _ in obstacle_dists:
                use_outer_lane = random.choice((False, True))
                obstacle_lanes.append(lane_choices[use_outer_lane])

            def arr(pt):
                return [pt.x,pt.y]

            def angle(x, y):
                a = math.degrees(math.atan2(
                    y[1] - x[1],
                    y[0] - x[0]
                ))
                return a

            # Car at point P drives distance R in direction HEADING (degrees from +X axis), new location will be point H
            def heading_point(p, heading, r):
                h = (
                    p[0] + r * math.cos(math.radians(heading)),
                    p[1] + r * math.sin(math.radians(heading))
                )
                return h

            def dist(p1, p2):
                return math.hypot(p1[0] - p2[0], p1[1] - p2[1])

            new_obstacles = []
            for obstacle_dist, obstacle_lane in zip(obstacle_dists, obstacle_lanes):

                obj_ctr_pos = center_line.interpolate(obstacle_dist)
                obj_lane_dist = obstacle_lane.project(obj_ctr_pos)
                obj_lane_pos = arr(obstacle_lane.interpolate(obj_lane_dist))
                obj_ctr_pos = arr(obj_ctr_pos)

                # ----------------------------------
                # Pick a point just off the track on that lane's side
                obj_heading = angle(obj_ctr_pos, obj_lane_pos)  # Heading from centerline toward object location
                obj_offset = 1.1 # How far from centerline should the object be?
                min_offset = obj_offset - 0.01 # epsilon
                done = False
                obj_pos = [0.0,0.0]

                # Check that this object is a safe distance from the track and other objects
                while not done:
                    obj_pos = heading_point(obj_ctr_pos, obj_heading, obj_offset)
                    ctr_pos = arr(center_line.interpolate(center_line.project(Point(*obj_pos))))
                    ctr_dist = dist(obj_pos, ctr_pos)

                    if ctr_dist <= min_offset:
                        # Bad - object position is closer to some other part of the track (corner, etc), move it further away and try again
                        obj_offset += 0.2
                        print("Object too close to track, moving.")
                    else:
                        # Check distance to other objects
                        done = True
                        for pos in obstacle_poses:
                            if dist(obj_pos, pos) <= min_offset:
                                # Bad - object is too close to another object
                                obj_offset += 0.2
                                done = False
                                print("Object too close to another object, moving.")
                    # done = True

                obstacle_poses.append(obj_pos)
                new_obstacles.append(obj_pos)

            return new_obstacles
        # -------------------------------------------------

        center_line = self.track_data.center_line

        # Extract the obstacle positions for existing obstacles
        obj_pos = [[o.position.x,o.position.y] for o in obstacle_poses]
        new_pos = make_off_track_obstacles(self.min_obstacle_dist,self.track_data.inner_lane,center_line,self.track_data.outer_lane,obj_pos)

        for idx,pos in enumerate(new_pos):

            obj_dist = center_line.project(Point(*pos))
            obstacle_pose = center_line.interpolate_pose(obj_dist)

            # Replace pose position with randomized position
            obstacle_pose.position.x = pos[0]
            obstacle_pose.position.y = pos[1]
            obstacle_pose.position.z = self.obstacle_z_pos[self.obstacle_types[idx]]

            # ----------------------------------
            # Spin the model to a random orientation...
            orientation = euler_to_quaternion(yaw = math.pi * random.random())
            obstacle_pose.orientation.x = orientation[0]
            obstacle_pose.orientation.y = orientation[1]
            obstacle_pose.orientation.z = orientation[2]
            obstacle_pose.orientation.w = orientation[3]
            # ----------------------------------

            obstacle_poses.append(obstacle_pose)

        return obstacle_poses
    # -------------------------------------------------


    def _compute_obstacle_poses(self):
        obstacle_dists = []
        obstacle_lanes = []
        lane_choices = (self.track_data.inner_lane, self.track_data.outer_lane)
        # use fix obstacle locations
        if self.object_locations:
            for object_location in self.object_locations:
                # index 0 is obstacle_ndist and index 1 is obstacle_lane
                object_location = object_location.split(",")
                obstacle_dists.append(float(object_location[0]) * \
                                      self.track_data.center_line.length)
                # Inner lane is 1, outer lane is -1. If True, use outer lane
                obstacle_lanes.append(lane_choices[int(object_location[1]) == -1])
        else:
            # Start with equally spaced
            obstacle_start_dist = self.min_obstacle_dist
            obstacle_end_dist = self.track_data.center_line.length - 1.0
            obstacle_dists = np.linspace(obstacle_start_dist, obstacle_end_dist, self.num_obstacles)
            # Perturb to achieve randomness
            if self.randomize:
                i_obstacle = list(range(self.num_obstacles))
                random.shuffle(i_obstacle)
                for i in i_obstacle:
                    lo = obstacle_start_dist if (i == 0) \
                         else obstacle_dists[i-1] + self.min_obstacle_dist
                    hi = obstacle_end_dist if (i == self.num_obstacles-1) \
                         else obstacle_dists[i+1] - self.min_obstacle_dist
                    if lo < hi:
                        obstacle_dists[i] = random.uniform(lo, hi)

                # Select a random lane for each obstacle
                for _ in obstacle_dists:
                    use_outer_lane = random.choice((False, True))
                    obstacle_lanes.append(lane_choices[use_outer_lane])
            else:
                # Alternate between lanes for each obstacle
                use_outer_lane = False
                for _ in obstacle_dists:
                    obstacle_lanes.append(lane_choices[use_outer_lane])
                    use_outer_lane = not use_outer_lane

        # Compute the obstacle poses
        obstacle_poses = []
        for idx, obstacle_dist, obstacle_lane in zip(range(len(obstacle_dists)), obstacle_dists, obstacle_lanes):
            obstacle_pose = obstacle_lane.interpolate_pose(
                obstacle_lane.project(self.track_data.center_line.interpolate(obstacle_dist)))
            obstacle_pose.position.z = self.obstacle_z_pos[self.obstacle_types[idx]]

            # Spin the model to a random orientation...
            orientation = euler_to_quaternion(yaw = math.pi * random.random())
            obstacle_pose.orientation.x = orientation[0]
            obstacle_pose.orientation.y = orientation[1]
            obstacle_pose.orientation.z = orientation[2]
            obstacle_pose.orientation.w = orientation[3]

            obstacle_poses.append(obstacle_pose)

        # Generate a random placement of off-track objects
        obstacle_poses = self._randomize_off_track_obstacles(obstacle_poses)

        # Return the poses
        return obstacle_poses

    def _spawn_obstacles(self):
        for obstacle_name, obstacle_pose, obstacle_type in zip(self.obstacle_names, self.obstacle_poses, self.obstacle_types):
            self.spawn_sdf_model(obstacle_name, self.obstacle_sdf[obstacle_type], '/{}'.format(obstacle_name), obstacle_pose, '')
            self.track_data.initialize_object(obstacle_name, obstacle_pose, self.obstacle_dimensions[obstacle_type])

    def _reset_obstacles(self):
        for obstacle_name, obstacle_pose in zip(self.obstacle_names, self.obstacle_poses):
            obstacle_state = ModelState()
            obstacle_state.model_name = obstacle_name

            # Spin the model to a random orientation...
            orientation = euler_to_quaternion(yaw = math.pi * random.random())
            obstacle_pose.orientation.x = orientation[0]
            obstacle_pose.orientation.y = orientation[1]
            obstacle_pose.orientation.z = orientation[2]
            obstacle_pose.orientation.w = orientation[3]

            obstacle_state.pose = obstacle_pose
            obstacle_state.twist.linear.x = 0
            obstacle_state.twist.linear.y = 0
            obstacle_state.twist.linear.z = 0
            obstacle_state.twist.angular.x = 0
            obstacle_state.twist.angular.y = 0
            obstacle_state.twist.angular.z = 0
            SetModelStateTracker.get_instance().set_model_state(obstacle_state)

    def _update_track_data_object_poses(self):
        '''update object poses in track data'''
        for obstacle_name, obstacle_pose in zip(self.obstacle_names, self.obstacle_poses):
            self.track_data.update_object_pose(obstacle_name, obstacle_pose)

    @property
    def action_space(self):
        return None

    def reset_agent(self):
        self.obstacle_poses = self._compute_obstacle_poses()
        self._reset_obstacles()
        self._update_track_data_object_poses()

    def send_action(self, action):
        pass

    def update_agent(self, action):
        self._update_track_data_object_poses()
        return {}

    def judge_action(self, agents_info_map):
        for agent_name, agent_info in agents_info_map.items():
            # check racecar crash with a obstacle
            crashed_object_name = agent_info[AgentInfo.CRASHED_OBJECT_NAME.value] \
                if AgentInfo.CRASHED_OBJECT_NAME.value in agent_info else ''
            # only trainable racecar agent has 'obstacle' as possible crashed object
            if OBSTACLE_NAME_PREFIX in crashed_object_name:
                self._reset_obstacles()
                break
        return None, None, None

    def finish_episode(self):
        pass
